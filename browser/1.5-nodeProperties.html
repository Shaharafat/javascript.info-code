<!-- âœ… The "node type " property -->
<!-- 
  âœ… elem.nodeType == 1 -> for element nodes
  âœ… elem.nodeType == 2 -> for text nodes
  âœ… elem.nodeType == 1 -> for document object
 -->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Node type</title>
    <style>
      body {
        background-color: red;
      }
    </style>
  </head>
  <body>
    <p>A paragraph</p>
    <div>A div</div>
    <!-- ğŸ‘ testing outerHTML on it -->
    <div id="divOuter">Hello,world</div>

    <script>
      let elem = document.body;

      console.log(elem);
      console.log(elem.nodeType); // â—ï¸ 1==element

      // first child
      console.log(elem.firstChild);
      console.log(elem.firstChild.nodeType); // â—ï¸ 3==text

      // document object
      console.log(document.nodeType); // â—ï¸ 9 == document object

      console.log(elem instanceof Comment);
      console.log(elem instanceof Text);
      console.log(elem instanceof Element);

      // ğŸ‘ we can read nodeType. not change it.

      // âœ… nodeName and tagName

      /*
       * â“ Is there any difference between tagName and nodeName?
       * Sure, the difference is reflected in their names, but is indeed a bit subtle.

       * The tagName property exists only for Element nodes.
       * The nodeName is defined for any Node:
          * for elements it means the same as tagName.
          * for other node types (text, comment, etc.) it has a string with the node type.
      */
      console.log(elem.firstChild.tagName); // âŒ undefined. because it is a text node.
      console.log(elem.firstChild.nodeName); // âœ… #text

      console.log(" âŒ " + document.tagName); // âŒ undefined
      console.log(" âœ… " + document.nodeName); // âœ… #document

      // â—ï¸ In HTML mode tag/node name is always uppercase "BODY"
      console.log(` ğŸ‘ ${elem.tagName} is uppercased.`);

      // âœ… innerHTML : the contents
      // â—ï¸ innerHTML property allows to get the HTML element
      // â—ï¸ ğŸ‘ as a string. we can also modify it.

      // console.log(elem.innerHTML); // ğŸ‘ whole body content
      elem.innerHTML = "The new BODY";
      console.log(elem.innerHTML); // âœ… replace it.

      // âŒ we can try to insert invalid HTML.
      // the browser will fix our errors.

      elem.innerHTML = `<b>test`;
      // ğŸ‘ browser will fix the error I did in above line.
      console.log(elem.innerHTML);

      // ğŸ‘ ğŸ‘ if innerHTML inserts a script tag into document.
      // it becomes a part of HTML, but doesn't execute.

      // âŒ âŒ don't use elem.innerHTML += "..."
      // it does a full overwrite.

      // âœ… outerHTML:  property contains the full HTML of the element.
      // That's like innerHTML plus the element itself.
      console.log(elem.outerHTML);

      /*
         * Beware: unlike innerHTML, writing to outerHTML does not change the element. Instead, it replaces it in the DOM.

         * Yeah, sounds strange, and strange it is, thatâ€™s why we make a separate note about it here. Take a look.

        * So what happened in div.outerHTML=... is:

        * div was removed from the document.
        * Another piece of HTML <p>A new element</p> was inserted in its place.
        * div still has its old value. The new HTML wasnâ€™t saved to any variable.

         */

      elem.innerHTML = `<b id="boldTxt" hidden>Test</b>
      <div id="divOuter">Hello world!</div>`;

      let divs = document.querySelector("#divOuter");
      console.log(divs.outerHTML);
      divs.outerHTML = `<p id="newElem">Changing using outerHTML</p>`;
      console.log(elem.innerHTML);
      let newElem = document.querySelector("#newElem");
      console.log(newElem);

      newElem.style.color = "yellow";

      // // ğŸ‘ divs is no more n the DOM tree.
      divs.innerHTML = "hey";
      console.log(elem.innerHTML);
      console.log(divs);

      // âœ… nodeValue/ data : text node content.
      // â—ï¸â—ï¸ Other node types, such as text nodes, have their counterpart: 
      // nodeValue and data properties. These two are almost the same for 
      //practical use, there are only minor specification differences. So weâ€™ll 
      // use data, because itâ€™s shorter.

      let text = elem.firstChild;
      console.log(text.firstChild.data); // data from <b> element
      text.firstChild.data = "editing using node value" // ğŸ‘
      console.log(text.firstChild.data);
      
      // âœ… textContent : pure Text
      // â—ï¸ The textContent provides access to the text inside the element: 
      // only text, minus all <tags>.

        console.log(elem.textContent); // ğŸ‘
        console.log(text.firstChild.textContent);
        text.firstChild.textContent = "<p> just a paragraph inserting using textContent</p>"
        console.log(text.firstChild.textContent);
        console.log(text);
        
        console.log(elem.innerHTML);
        let btxt = document.querySelector("#boldTxt")
        console.log(btxt);
        
        btxt.hidden=true;

        // ğŸ‘ A blinking element.
        setInterval(()=>btxt.hidden = !btxt.hidden,600)
      
    </script>
  </body>
</html>
