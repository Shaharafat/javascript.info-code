<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  

  <script>

    // ðŸ‘€ width/height of the window
/*
 * To get window width and height we can use clientWidth/clientHeight of document.documentElement
*/


/* 
 * Not window.innerWidth/Height

 * Browsers also support properties window.innerWidth/innerHeight. They look like what we want. So why not to use them instead?

 * If there exists a scrollbar, and it occupies some space, clientWidth/clientHeight provide the width/height without it (subtract it). In other words, they return width/height of the visible part of the document, available for the content.

 * â€¦And window.innerWidth/innerHeight include the scrollbar.
*/

console.log(`root client width: ${ document.documentElement.clientWidth }`)

console.log(`root client Height : ${ document.documentElement.clientHeight }`)


// ðŸ‘€ width/height of the document
/*
 * Theoretically, as the root document element is document.documentElement, and it encloses all the content, we could measure document full size as document.documentElement.scrollWidth/scrollHeight.

 * But on that element, for the whole page, these properties do not work as intended. In Chrome/Safari/Opera if thereâ€™s no scroll, then documentElement.scrollHeight may be even less than documentElement.clientHeight! Sounds like a nonsense, weird, right?
*/

console.log(`Current ScrollTop : ${document.documentElement.scrollTop}`)

console.log(`Current ScrollLeft : ${document.documentElement.scrollLeft}`)

// âœ… Luckily, we donâ€™t have to remember these peculiarities at all, because the scroll is available in the special properties window.pageXOffset/pageYOffset

console.log(`current scrollTop using window.pageYOffset : ${window.pageYOffset}`)
console.log(`current scrollLeft using window.pageXOffset : ${window.pageXOffset}`);



  </script>
</body>
</html>

